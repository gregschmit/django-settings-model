import os
from pathlib import Path
from pytz import common_timezones
import sys

from django.conf import settings
from django.db import models, transaction
from django.db.utils import OperationalError
from django.utils.translation import gettext_lazy as _

from .settings import get_setting


CONFIG_FILE = os.path.join(os.path.dirname(__file__), "config.py")


class SettingsModel(models.Model):
    """
    An abstract model that tracks settings and touches certain files on save to signal
    the web server to reload.
    """

    name = models.CharField(default="Default", max_length=255, unique=True, blank=False)
    is_active = models.BooleanField(default=True)

    # class constants, overridable by subclasses
    READABLE_INDEX = 2
    WRITABLE_INDEX = 3
    CREATE_INITIAL = True

    class Meta:
        abstract = True

    def __str__(self):
        return self.name

    @property
    def __config__(self):
        """
        This config maps fields to the settings file variables.

        Returns a list/tuple of tuples in the format:
            (field_name, setting_name, readable, writable)

        For example:
            [
                ("debug_mode", "DEBUG", True, True),
                ("from_email", "DEFAULT_FROM_EMAIL", True, True),
            ]

        This should be implemented by subclasses with a normal list or tuple.
        """
        raise NotImplementedError

    def encode_setting(self, field):
        """
        Given a field, convert the field to a string representing the Python code that
        should be written to the settings file.
        """
        raise NotImplementedError

    @classmethod
    def init(cls):
        """
        See if we have settings. If so, read the actual settings values into it.
        """
        try:
            s = cls.objects.filter(is_active=True).first()
            if s:
                s.read_settings()
            elif cls.CREATE_INITIAL:
                try:
                    os.remove(CONFIG_FILE)
                except FileNotFoundError:
                    pass
                s = cls()
                s.read_settings()
        except OperationalError:
            print("settings_model: db not ready")
            return

    def read_settings(self):
        """
        Read settings from Django into this instance.
        """
        for s in [x for x in self.__config__ if x[self.READABLE_INDEX]]:
            try:
                setattr(self, s[0], getattr(settings, s[1]))
            except AttributeError:  # setting not found
                pass
        return self.save(reboot=False)

    def write_settings(self):
        """
        Write the settings defined by this instance to the config file.
        """
        text = '"""AUTOGENERATED CONTENT; CHANGES WILL BE OVERWRITTEN"""\n\n'
        for s in [x for x in self.__config__ if x[self.WRITABLE_INDEX]]:
            content = self.encode_setting(getattr(self, s[0]))
            if content:
                text += "{} = {}\n".format(s[1], content)

        # write to config.py
        with open(CONFIG_FILE, "w") as f:
            f.write(text)

    def save(self, *args, **kwargs):
        """
        Save this instance, check to ensure only one instance is active, and reboot, if
        necessary.
        """
        # extract custom kwargs
        raw = kwargs.pop("raw", False)
        reboot = kwargs.pop("reboot", True)

        # skip magic and just save
        if raw:
            return super().save(*args, **kwargs)

        # get active settings
        active_settings = list(type(self).objects.filter(is_active=True))

        # active management
        if not active_settings:
            # set as active if there are none
            self.is_active = True
        else:
            # disable extra active settings
            if not self.is_active:
                active_settings = active_settings[1:]
            for s in active_settings:
                s.is_active = False
                s.save(raw=True)

        # if we are saving an active settings instance, reboot the web server
        if self.is_active:
            if reboot:
                transaction.on_commit(lambda: self.reboot_server())
        return super().save(*args, **kwargs)

    def reboot_server(self, commit=True):
        """
        Commit the configuration to disk and reboot the web server by touching the
        specified configuration files.
        """
        if commit:
            print("settings_model: committing config to disk...")
            self.write_settings()

        # get reboot files
        touch_files = get_setting("SETTINGS_MODEL_REBOOT_FILES")
        if not touch_files:
            touch_files = [os.path.join(get_setting("BASE_DIR"), "manage.py")]  # dev server
            try:
                touch_files.append(
                    sys.modules[get_setting("WSGI_APPLICATION").rsplit(".", 1)[0]].__file__
                )  # wsgi (apache/nginx)
            except (AttributeError, IndexError):
                pass

        # touch files to tell the webserver to reboot
        print("settings_model: signalling webserver reboot by touching:")
        for f in touch_files:
            p = Path(f)
            if p.exists():
                print("settings_model:  - {}".format(f))
                p.touch()
            else:
                print("settings_model:  - {} (skipped, doesn't exist)".format(f))


class Settings(SettingsModel):
    """
    A basic implementation of a settings model.
    """

    debug_mode = models.BooleanField(default=True)
    secret_key = models.CharField(max_length=255, blank=True)
    tz_choices = [(x, x) for x in common_timezones]
    time_zone = models.CharField(max_length=255, blank=True, choices=tz_choices)
    append_slash = models.BooleanField(default=False)
    allowed_hosts = models.CharField(
        max_length=255,
        blank=True,
        help_text=_(
            "A comma-delimited list of hosts for which this application is allowed to "
            "respond to."
        ),
    )

    __config__ = [
        ("debug_mode", "DEBUG", True, True),
        ("secret_key", "SECRET_KEY", True, True),
        ("time_zone", "TIME_ZONE", True, True),
        ("append_slash", "APPEND_SLASH", True, True),
        ("allowed_hosts", "ALLOWED_HOSTS", True, True),
    ]

    def encode_setting(self, field):
        if field is self.allowed_hosts:
            return str(field)
        return field.__repr__()

    class Meta:
        verbose_name = verbose_name_plural = "Settings"
